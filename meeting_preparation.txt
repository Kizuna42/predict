# 空調システム室内温度予測モデル開発プロジェクト - ミーティング準備資料

## プロジェクト全体像

### 目的
- 空調システムにおける室内温度の予測モデル開発
- 各ゾーンの将来的な温度値（5分後、10分後、15分後、20分後、30分後）を予測

### 使用モデル
- LightGBMベースの回帰モデル
- 物理法則を考慮した特徴量エンジニアリングで強化
- 多項式特徴量（2次までの交互作用）を活用

### 使用特徴量
1. **基本特徴量**
   - 温度センサーデータ（`sens_temp_{zone}`）
   - 空調機の運転状態（`AC_valid_{zone}`, `AC_mode_{zone}`）
   - 空調設定値（`AC_set_{zone}`）
   - 外気温データ（`atmospheric temperature`）
   - 日射量データ（`total solar radiation`）

2. **物理ベース特徴量**
   - 温度変化率（一次微分）
   - 温度加速度（二次微分）
   - 熱伝達効率指標
   - サーモ状態（センサー温度と設定温度の差）
   - 温度振動性（変化方向の反転頻度）
   - 設定温度との差の変化率（制御応答の指標）

3. **未来の説明変数（データリーク懸念あり）**
   - 未来の外気温データ
   - 未来の日射量データ
   - 未来の空調サーモ状態
   - 未来の空調運転状態（発停）
   - 未来の空調モード（冷房/暖房）

### 入力データ構造
- AllDayData.csv（約119MB）のデータを使用
- 12ゾーン（L系統[0,1,6,7]、M系統[2,3,8,9]、R系統[4,5,10,11]）
- 時系列データ（一定間隔でのサンプリング）

### 出力結果と利用用途
- 各ゾーンの将来温度予測値
- モデル性能指標（RMSE, MAE, R²）
- 特徴量重要度分析
- LAG依存度分析（過去データへの依存度評価）

## モデルの問題点と警告メッセージ

### 1. データリークの兆候
- 未来の説明変数（空調設定、運転状態）を使用している
- 実運用時には未来の値を入力する仕組みが不明確
- 予測時に「これから設定する温度・状態」をどう扱うべきかが課題

### 2. LightGBMからの警告メッセージ
- 「No further splits with positive gain」
  - 決定木がこれ以上分割しても利得が得られない状況
  - モデルの精度には直接影響しない（R²=0.8868と高精度維持）
  - 単なる情報提供的な警告

- 「Found whitespace in feature_names」
  - 特徴量名に空白が含まれていることの警告
  - モデルの予測能力には影響なし

### 3. 特徴量名の重複問題
- 多項式特徴量生成時に重複名が発生
- `select_important_features`と`train_physics_guided_model`関数で対処済み
- 重複検出と排除のロジックを追加して解決

## 核となるコード

### 未来特徴量生成（データリーク懸念部分）
```python
def create_future_explanatory_features(df, base_features_config, horizons_minutes, time_diff_seconds, is_prediction_mode=False):
    # 制御可能なパラメータと環境データの前缀
    controllable_params_prefixes = ['AC_', 'thermo_state']
    environmental_prefixes = ['atmospheric', 'solar', 'radiation']

    for horizon in horizons_minutes:
        # シフト量を計算
        shift_steps = int(horizon * 60 / time_diff_seconds)

        for config in base_features_config:
            base_col_name = config['name']

            is_controllable = any(base_col_name.startswith(prefix) for prefix in controllable_params_prefixes)
            is_environmental = any(prefix in base_col_name.lower() for prefix in environmental_prefixes)

            if is_controllable or is_environmental:
                future_col = f"{base_col_name}_future_{horizon}"

                if not is_prediction_mode:
                    # 学習時: 実際の未来値を使用
                    df_copy[future_col] = df_copy[base_col_name].shift(-shift_steps)
                else:
                    # 予測時: プレースホルダーを作成（NaNまたは0で初期化）
                    df_copy[future_col] = np.nan
```

### 物理ベース特徴量生成
```python
def create_physics_based_features(df, zone_nums):
    # 熱力学の法則に基づく特徴量
    for zone in zone_nums:
        if f'sens_temp_{zone}' in df.columns:
            # 温度変化率（一次微分）
            df_copy[f'temp_rate_{zone}'] = df_copy[f'sens_temp_{zone}'].diff()

            # 温度加速度（二次微分 - 温度変化の変化率）
            df_copy[f'temp_accel_{zone}'] = df_copy[f'temp_rate_{zone}'].diff()

            # 設定温度との差（熱力学における駆動力）
            if f'AC_set_{zone}' in df.columns:
                df_copy[f'temp_diff_to_setpoint_{zone}'] = df_copy[f'sens_temp_{zone}'] - df_copy[f'AC_set_{zone}']

                # 熱伝達の効率性指標（温度差に対する変化率の比）
                df_copy[f'heat_transfer_efficiency_{zone}'] = df_copy[f'sens_temp_{zone}'].diff() / df_copy[f'temp_diff_to_setpoint_{zone}'].abs()
```

### モデルトレーニング
```python
def train_physics_guided_model(X_train, y_train, params=None):
    # 列名の重複チェック
    if len(X_train.columns) != len(set(X_train.columns)):
        print("警告: トレーニングデータの列名に重複があります。重複を排除します。")
        # 重複を排除した特徴量のみを使用
        unique_cols = []
        seen_cols = set()
        for col in X_train.columns:
            if col not in seen_cols:
                unique_cols.append(col)
                seen_cols.add(col)

        X_train = X_train[unique_cols]

    # パラメータが指定されていない場合は、デフォルト値を使用
    if params is None:
        params = LGBM_PARAMS.copy()

    # 警告メッセージを抑制するため、verboseを-1に設定
    params['verbose'] = -1

    # 物理モデルに適したパラメータを使用
    lgb_model = lgb.LGBMRegressor(**params)

    try:
        # Pythonの標準警告を一時的に抑制
        import warnings
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")

            # 急激な温度変化に対する重み付け
            temp_changes = y_train.diff().abs().fillna(0)
            weights = 1 + temp_changes / temp_changes.mean()

            # スパイクの影響を制限
            max_weight = 3.0  # 最大ウェイト値を制限
            weights = weights.clip(upper=max_weight)

            lgb_model.fit(X_train, y_train, sample_weight=weights)

        return lgb_model
    except Exception as e:
        # エラー時のフォールバック処理...
```

## 想定される論点・質問事項

### 1. 「未来情報」の扱い
- **現状の問題**: 予測時に未来のAC設定値・運転状態が必要
- **対応案1**: シナリオベースの予測
  - 複数の未来シナリオ（設定温度変更なし/あり、運転状態変更なし/あり）を想定して予測
  - ユーザーが予測時に「これからの操作予定」を入力
- **対応案2**: 未来情報を使わないモデル
  - 現在の状態のみを使った予測モデルに変更
  - 精度は落ちるが、実運用上のデータリークが解消
- **対応案3**: 制御スケジュール情報の活用
  - 事前に設定された空調制御スケジュールがあれば、それを未来情報として使用

### 2. 精度の評価基準
- **現状の評価指標**: RMSE, MAE, R²
- **議論ポイント**:
  - 目標精度はどの程度か？（例：R²>0.85、RMSE<0.5°C）
  - 精度とリアルタイム性のトレードオフ
  - 予測ホライゾンによる精度の期待値変化（5分後vs30分後）

### 3. モデルの実運用シナリオ
- **想定される用途**:
  - リアルタイム予測（常時実行）
  - バッチ予測（定期的に実行）
  - オンデマンド予測（ユーザーが要求時に実行）
- **議論ポイント**:
  - 予測結果の更新頻度
  - 予測モデルの再学習頻度
  - モデルのデプロイ方法（組み込み、API、クラウド）

### 4. ビジネス価値
- **議論ポイント**:
  - このモデルによって得られる具体的なメリット
  - 空調制御最適化への活用方法
  - エネルギー消費削減の可能性
  - 他のビル・施設への展開可能性
